#if !defined(BOOST_VMD_EQUAL_IDENTIFIER_HPP)
#define BOOST_VMD_EQUAL_IDENTIFIER_HPP

#include <boost/vmd/detail/vmd_detail_setup.hpp>

#if BOOST_PP_VARIADICS

#include <boost/preprocessor/control/while.hpp>
#include <boost/preprocessor/tuple/elem.hpp>
#include <boost/preprocessor/variadic/to_tuple.hpp>
#include <boost/vmd/detail/vmd_detail_equal_identifier.hpp>

/*

  The succeeding comments in this file are in doxygen format.

*/

/** \file
*/

/** \def BOOST_VMD_EQUAL_IDENTIFIER(parameter,...)

    \brief Tests whether a parameter is the same as a particular identifier.

    The macro checks to see if the 'parameter' is equal to a particular identifier.
    meaning that it is the exact same preprocessing token.
    An identifier which is checked is mapped by a key ( see below ),
    which must be unique each time this macro is invoked.
    
    It returns the index, starting with 1, of the identifier which it matches, else returns 0.
    The parameter must be a C++ identifier,
    ie. it must consist of letters, numbers, and underscores.
    
    parameter = a C++ identifier to test
    ...       = One or more as C++ identifiers as unique 'keys' whenever the macro is invoked.
                The idea is not to duplicate any key that another library may use.
             
             A unique key should not begin with an underscore. It may end
             with an underscore only if the value to be tested does not begin
             with an underscore. It may contain underscores.
             
             Two different suggested ways to generate a unique key are:
             1) Use a specific mnemonic for a particular module and concatenate an increasing
                numeric value, perhaps separated by an underscore, to it each time you use it, 
                ie. TTI_0, TTI_1, TTI_2 etc.
             2) use a GUID ( 128 bit unique number ) generated by the OS or software, prefixed by some alphabetic.

    returns = expands to the index, starting with 1, of the particular identifier it matches, otherwise expands to 0.
    
    The 'identifier' s to be tested against is specified by having the end-user 
    defining an object-like macro, which does not expand to anything, whose form is:
    
    #define BOOST_VMD_MAP_'key''identifier'
    
    where 'key' is a key passed to the BOOST_VMD_EQUAL_IDENTIFIER macro,
          'identifier' is the value to be tested against.
    
    As an example, let us suppose that within a library called 'plane_geometry' I want to
    use the BOOST_VMD_EQUAL_IDENTIFIER macro 4 times, checking whether a parameter is equal 
    to 'SQUARE' the first time, 'TRIANGLE' the second time, 'CIRCLE' the third time, and any
    one of them the fourth time.
    
    First I write my object-like macros
    
    #define BOOST_VMD_MAP_PLANEGEOMETRY_1_SQUARE
    #define BOOST_VMD_MAP_PLANEGEOMETRY_2_TRIANGLE
    #define BOOST_VMD_MAP_PLANEGEOMETRY_3_CIRCLE
    
    If I want to check if some preprocessor argument 'x' is SQUARE I invoke:
    
    BOOST_VMD_EQUAL_IDENTIFIER(x,PLANEGEOMETRY_1_)
    
    If I want to check if some preprocessor argument 'x' is TRIANGLE I invoke:
    
    BOOST_VMD_EQUAL_IDENTIFIER(x,PLANEGEOMETRY_2_)
    
    If I want to check if some preprocessor argument 'x' is CIRCLE I invoke:
    
    BOOST_VMD_EQUAL_IDENTIFIER(x,PLANEGEOMETRY_3_)
    
    If I want to check if some preprocessor argument 'x' is either a CIRCLE, TRIANGLE, or SQUARE I invoke:
    
    BOOST_VMD_EQUAL_IDENTIFIER(x,PLANEGEOMETRY_1_,PLANEGEOMETRY_2_,PLANEGEOMETRY_3_)
    
*/

#define BOOST_VMD_EQUAL_IDENTIFIER(parameter,...) \
	BOOST_PP_TUPLE_ELEM \
		( \
		3, \
		BOOST_PP_WHILE \
			( \
			BOOST_VMD_DETAIL_EQUAL_IDENTIFIER_PRED, \
			BOOST_VMD_DETAIL_EQUAL_IDENTIFIER_OP, \
			(parameter,BOOST_PP_VARIADIC_TO_TUPLE(__VA_ARGS__),0,0) \
			) \
		) \
/**/

#endif /* BOOST_PP_VARIADICS */
#endif /* BOOST_VMD_EQUAL_IDENTIFIER_HPP */
