#if !defined(BOOST_VMD_IS_IDENTIFIER_HPP)
#define BOOST_VMD_IS_IDENTIFIER_HPP

#include <boost/vmd/detail/setup.hpp>

#if BOOST_PP_VARIADICS

#include <boost/vmd/identifier.hpp>
#include <boost/vmd/detail/is_identifier.hpp>

/*

  The succeeding comments in this file are in doxygen format.

*/

/** \file
*/

/** \def BOOST_VMD_IS_IDENTIFIER(parameter,keys)

    \brief Tests whether a parameter is the same as a particular identifier.

    The macro checks to see if the 'parameter' is equal to a particular identifier.
    meaning that it is the exact same preprocessing token.
    An identifier which is checked is mapped by a key ( see below ),
    which must be unique each time this macro is invoked.
    
    It returns the index, starting with 1, of the identifier which it matches, else returns 0.
    The parameter must be a C++ identifier,
    ie. it must consist of letters, numbers, and underscores.
    
    parameter = a C++ identifier to test
    keys      = The variadic data may take one of two forms:
    			it is either a C++ identifier as a unique 'key' ( see below )
    			or a Boost PP tuple of the unique 'key's. 
    			
                The idea of a unique 'key' is not to duplicate any key that another library may use.
             
			    A unique key should not begin with an underscore. It may end
			    with an underscore only if the value to be tested does not begin
			    with an underscore. It may contain underscores.
			 
			    Two different suggested ways to generate a unique key are:
			    1) Use a specific mnemonic for a particular module and concatenate an increasing
				   numeric value, perhaps separated by an underscore, to it each time you use it, 
				   ie. TTI_0, TTI_1, TTI_2 etc.
			    2) use a GUID ( 128 bit unique number ) generated by the OS or software, prefixed by some alphabetic.

				The 'identifier' to be tested against is specified by having the end-user 
				defining an object-like macro, which does not expand to anything, whose form is:
				
				#define BOOST_VMD_MAP_'key''identifier'
				
				where 'key' is the key, or one of the keys, passed in this parameter,
					  'identifier' is a value to be tested against.
					  
    returns = expands to the index, starting with 1, of the particular identifier it matches, otherwise expands to 0.
    
    As an example, let us suppose that within a library called 'plane_geometry' I want to
    use the BOOST_VMD_IS_IDENTIFIER macro 4 times, checking whether a parameter is equal 
    to 'SQUARE' the first time, 'TRIANGLE' the second time, 'CIRCLE' the third time, and any
    one of them the fourth time.
    
    First I write my object-like macros
    
    #define BOOST_VMD_MAP_PLANEGEOMETRY_1_SQUARE
    #define BOOST_VMD_MAP_PLANEGEOMETRY_2_TRIANGLE
    #define BOOST_VMD_MAP_PLANEGEOMETRY_3_CIRCLE
    
    If I want to check if some preprocessor argument 'x' is SQUARE I invoke:
    
    BOOST_VMD_IS_IDENTIFIER(x,PLANEGEOMETRY_1_) or 
    BOOST_VMD_IS_IDENTIFIER(x,(PLANEGEOMETRY_1_))
    
    If I want to check if some preprocessor argument 'x' is TRIANGLE I invoke:
    
    BOOST_VMD_IS_IDENTIFIER(x,PLANEGEOMETRY_2_) or 
    BOOST_VMD_IS_IDENTIFIER(x,(PLANEGEOMETRY_2_))
    
    If I want to check if some preprocessor argument 'x' is CIRCLE I invoke:
    
    BOOST_VMD_IS_IDENTIFIER(x,PLANEGEOMETRY_3_) or 
    BOOST_VMD_IS_IDENTIFIER(x,(PLANEGEOMETRY_3_))
    
    If I want to check if some preprocessor argument 'x' is either a CIRCLE, TRIANGLE, or SQUARE I invoke:
    
    BOOST_VMD_IS_IDENTIFIER(x,(PLANEGEOMETRY_1_,PLANEGEOMETRY_2_,PLANEGEOMETRY_3_))
    
*/

#define BOOST_VMD_IS_IDENTIFIER(parameter,keys) \
	BOOST_VMD_DETAIL_IS_IDENTIFIER \
		( \
		BOOST_VMD_IDENTIFIER(parameter,keys) \
		) \
/**/

#endif /* BOOST_PP_VARIADICS */
#endif /* BOOST_VMD_IS_IDENTIFIER_HPP */
