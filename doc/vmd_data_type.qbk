[section:vmd_assert_data Verifying Boost PP data types]

There is no way to determine whether a macro parameter is a
given Boost PP data type. But one can come close to this 
functionality using variadic macros and the test for emptiness
in the VMD library which the BOOST_VMD_IS_EMPTY macro gives.
Therefore I have developed four macros, for each of the four 
Boost PP data types, which will produce a compiler error if a
parameter is not a given data type, else will output nothing.
These macros are:

# [macroref BOOST_VMD_ASSERT_IS_ARRAY](param), asserts that 'param' is a Boost PP array
# [macroref BOOST_VMD_ASSERT_IS_LIST](param), asserts that 'param' is a Boost PP list
# [macroref BOOST_VMD_ASSERT_IS_SEQ](param), asserts that 'param' is a Boost PP seq
# [macroref BOOST_VMD_ASSERT_IS_TUPLE](param), asserts that 'param' is a Boost PP tuple

Each of these act like a C++ assert-like macro. They output nothing if the 'param'
is of the known type, else produce a compiler error. Furthermore these macros,
like 'assert-like' macros, only check their 'param' in debug mode. This, however,
can be overridden by the BOOST_VMD_ASSERT_DATA macro. If it is defined and set
to 1, the macros will always check their 'param', otherwise if it is set to 0 
the 'param' is never checked.

The assert macros can be used in code to test whether a 'param' is of the expected 
Boost PP data type. It is not possible to create equivalent macros which return 1
when the 'param' is of the correct type, else return 0, because of the assert macros'
necessary reliance on BOOST_VMD_IS_EMPTY, which even in the best of conditions is slightly 
flawed. However the flaw in BOOST_VMD_IS_EMPTY, where a function-like macro name 
could produce a compiler error, is made use of in the assert macros so that the 
compiler error produced in that case will only occur when the assert macro verifies
that its 'param' is not the Boost PP data type being checked. Still there is the 
very slight flaw in the assert macros where its reliance on BOOST_VMD_IS_EMPTY 
could run into input being checked where a function-like macro name will produce 
the incorrect result from the BOOST_VMD_IS_EMPTY macro when using VC++. 
However this flaw is thought to be so slight, and an end-user's chance of inputting 
such data so minimal, that it was felt that such assert-like macros would be 
beneficial to macro programmers using Boost PP and VMD.

Another point to be made is that Boost PP array and list are also tuples. So
passing an array or list to BOOST_VMD_ASSERT_IS_TUPLE will assert that either one of those Boost PP data types 
is a valid tuple by not producing a compiler error.

A final point concerns using the assert macros with Visual C++. There is no way 
which I have been able to discover to produce a compiler error from within a
macro using Visual C++ without producing invalid C++ output to trigger the error.
If the VC++ compiler subsequently sees this output after the preprocessing stage
is complete it will create an error message.

Because of this the promise to produce no output in case of error from the assert 
macros must be amended for Visual C++. The compiler error when using Visual C++, 
and an assert macro fails, could be masked by using one of the assert macros in a 
situation where no output is generated by an enclosing macro. This case would occur 
if the result of one of the assert macros were embedded in another macro, and the 
embedded macro just ignores any "output" from VC++ when the assert macro fails. 
An admittedly artifical example using VC++ might be:

 #include <boost/vmd/tuple.hpp>

 #define IGNORE_TUPLE_CHECK(vcoutput) 
 #define USE_TUPLE(atuple) IGNORE_TUPLE_CHECK(BOOST_VMD_ASSERT_TUPLE(atuple)) PROCESS_TUPLE(atuple)
 
When USE_TUPLE is invoked using VC++, if the input is not actually a Boost PP tuple
BOOST_VMD_ASSERT_TUPLE will output incorrect C++. But since that incorrect output
is passed to another macro which just ignores it, the output will never appear after
the preprocessing stage so no compiler error will occur.

Individual header files can be used for each of the assert macros 
instead of including the general header file 'vmd.hpp'. The individual
header files are:

* 'array.hpp' for the BOOST_VMD_ASSERT_IS_ARRAY macro
* 'list.hpp' for the BOOST_VMD_ASSERT_IS_LIST macro
* 'seq.hpp' for the BOOST_VMD_ASSERT_IS_SEQ macro
* 'tuple.hpp' for the BOOST_VMD_ASSERT_IS_TUPLE macro.

[endsect]
