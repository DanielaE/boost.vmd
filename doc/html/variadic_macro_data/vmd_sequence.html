<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Parsing sequences</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Variadic Macro Data Library 1.8">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Variadic Macro Data Library 1.8">
<link rel="prev" href="vmd_generic.html" title="Generic macros for working with data types">
<link rel="next" href="vmd_sequence_convert.html" title="Converting sequences">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="vmd_generic.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="vmd_sequence_convert.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="variadic_macro_data.vmd_sequence"></a><a class="link" href="vmd_sequence.html" title="Parsing sequences">Parsing sequences</a>
</h2></div></div></div>
<h4>
<a name="variadic_macro_data.vmd_sequence.h0"></a>
      <span class="phrase"><a name="variadic_macro_data.vmd_sequence.standard_macro_parameter_usage"></a></span><a class="link" href="vmd_sequence.html#variadic_macro_data.vmd_sequence.standard_macro_parameter_usage">Standard
      macro parameter usage</a>
    </h4>
<p>
      In the normal use of Boost PP, data is passed as arguments to a macro in discrete
      units so that each parameter expects a single data type. A typical macro might
      be:
    </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">AMACRO</span><span class="special">(</span><span class="identifier">anumber</span><span class="special">,</span><span class="identifier">atuple</span><span class="special">,</span><span class="identifier">anidentifier</span><span class="special">)</span> <span class="identifier">someoutput</span>
</pre>
<p>
      where the 'atuple', having the form of ( data1, data2, data3 ), itself may
      contain different data types of elements.
    </p>
<p>
      This is the standard macro design and internally it is the easiest way to pass
      macro data back and forth. The Boost PP library has a rich set of functionality
      to deal with all of its high-level data types and variadic data, with its own
      simpler functionality, also offers another alternative to representing data.
    </p>
<p>
      Occasionally designers of macros, especially for the use of others programmers
      within a particular library, have expressed the need for a macro parameter
      to allow a more C/C++ like syntax where a single parameter might mimic a C++
      function-call or a C-like type modification syntax, or some other more complicated
      construct. Something along the lines of:
    </p>
<pre class="programlisting"><span class="identifier">areturn</span> <span class="identifier">afunction</span> <span class="special">(</span> <span class="identifier">aparameter1</span><span class="special">,</span> <span class="identifier">aparameter2</span><span class="special">,</span> <span class="identifier">aparameter3</span> <span class="special">)</span>
</pre>
<p>
      or
    </p>
<pre class="programlisting"><span class="special">(</span> <span class="identifier">type</span> <span class="special">)</span> <span class="identifier">data</span>
</pre>
<p>
      etc. etc.
    </p>
<p>
      In other words, from a syntactical level when designing possible macro input,
      is it possible to design parameter data to look more like C/C++ when macros
      are used in a library and still do a certain amount of preprocessor metaprogramming
      with such mixed token input ?
    </p>
<p>
      VMD has functionality which allows more than one type of preprocessing token,
      excluding an 'empty' token which always refers to some entire input, to be
      part of a single parameter of input data as a series of data, as long as all
      the top-level data of such a single parameter is of some VMD data type. What
      this means is that if some input consists of a series of data types it is possible
      to extract the data for each data type in that series.
    </p>
<p>
      In practicality what this means is that, given the examples just above, if
      'areturn', 'afunction', and 'data' are identifiers it would be possible to
      parse either of the two inputs above so that one could identify the different
      data types involved and do preprocessor metaprogramming based on those results.
    </p>
<h4>
<a name="variadic_macro_data.vmd_sequence.h1"></a>
      <span class="phrase"><a name="variadic_macro_data.vmd_sequence.sequence_definition"></a></span><a class="link" href="vmd_sequence.html#variadic_macro_data.vmd_sequence.sequence_definition">Sequence
      definition</a>
    </h4>
<p>
      I will be calling such input data, which consists of all top-level data types
      in a series, by the term of a 'sequence'. Each separate data type in the sequence
      is called an 'element'. In this definition of a 'sequence' we can have 0 or
      more elements, so that a sequence is a general name for any VMD inpute. A sequence
      is therefore any input VMD can parse, whether it is emptiness, a single element,
      or more than one element in a series. Therefore when we speak of VMD macros
      parsing input data we are really speaking of VMD macros parsing a sequence.
      A sequence can therefore also be part of a Boost PP composite data type, or
      variadic data, and VMD can still parse such an embedded sequence if asked to
      do so.
    </p>
<h4>
<a name="variadic_macro_data.vmd_sequence.h2"></a>
      <span class="phrase"><a name="variadic_macro_data.vmd_sequence.sequence_parsing"></a></span><a class="link" href="vmd_sequence.html#variadic_macro_data.vmd_sequence.sequence_parsing">Sequence
      parsing</a>
    </h4>
<p>
      Parsing a sequence means that VMD can step through each element of a sequence
      sequentially, determine the type and data of each element, then move on to
      the next element. Parsing is sequential and can only be done in a forward direction,
      but it can be done any number of times. In C++ iterator terms parsing is a
      forward iterator.
    </p>
<p>
      Working with a sequence is equivalent to using VMD macros generically.
    </p>
<p>
      Before I give an explanation of how to use a sequence using VMD generic functionality
      I would like to make two points:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          The possibility of working with a sequence which contains more than one
          data type for the preprocessor metaprogrammer can be easily abused. In
          general keeping things simple is usually better than making things overly
          complicated when it comes to the syntactical side of things in a computer
          language. A macro parameter syntactical possibility has to be understandable
          to be used.
        </li>
<li class="listitem">
          Using VMD to parse the individual data types of a sequence takes more preprocessing
          time than functionality offered with Boost PP data types, because a good
          deal of it is based on the repetitive parsing techniques.
        </li>
</ul></div>
<p>
      The one constraint in a sequence is that the top-level must consist of VMD
      data types, in other words preprocessor tokens which VMD understands. By top-level
      it is meant that a Boost PP composite data may have elements which VMD cannot
      parse but as long as the input consists of the composite data types and not
      the inner unparsable elements, VMD can parse the input. Therefore if preprocessor
      data is one of the examples above, you will be successful in using VMD. However
      if your preprocessor data takes the form of:
    </p>
<pre class="programlisting"><span class="special">&amp;</span><span class="identifier">name</span> <span class="identifier">identifier</span> <span class="special">(</span> <span class="identifier">param</span> <span class="special">)</span>
</pre>
<p>
      or
    </p>
<pre class="programlisting"><span class="identifier">identifier</span> <span class="string">"string literal"</span>
</pre>
<p>
      or
    </p>
<pre class="programlisting"><span class="identifier">identifier</span> <span class="special">+</span> <span class="identifier">number</span>
</pre>
<p>
      or
    </p>
<pre class="programlisting"><span class="identifier">identifier</span> <span class="special">+=</span> <span class="number">4.3</span>
</pre>
<p>
      etc. etc.
    </p>
<p>
      you will not be able to parse the data using VMD since '&amp;', "string
      literal", '+', '+=', and "4.3" are preprocessor tokens which
      are not top-level data types and therefore VMD cannot handle them at the parsing
      level. You can still of course pass such data as preprocessing input to macros
      but you cannot use VMD to recognize the parts of such data.
    </p>
<p>
      This is similar to the fact that VMD cannot tell you what type preprocessor
      data is as a whole, using any of the VMD identifying macros already discussed,
      if the type is not one that VMD can handle.
    </p>
<p>
      On the other hand you can still use VMD to parse such tokens in the input if
      you use Boost PP data types as top-level v-types to do so. Such as:
    </p>
<pre class="programlisting"><span class="special">(</span> <span class="special">&amp;</span><span class="identifier">name</span> <span class="special">)</span> <span class="identifier">identifier</span> <span class="special">(</span> <span class="identifier">param</span> <span class="special">)</span>
</pre>
<p>
      or
    </p>
<pre class="programlisting"><span class="identifier">identifier</span> <span class="special">(</span> <span class="string">"string literal"</span> <span class="special">)</span>
</pre>
<p>
      or
    </p>
<pre class="programlisting"><span class="identifier">identifier</span> <span class="special">(</span> <span class="special">+</span> <span class="special">)</span> <span class="identifier">number</span>
</pre>
<p>
      or
    </p>
<pre class="programlisting"><span class="identifier">identifier</span> <span class="special">(</span> <span class="special">+=</span> <span class="special">)</span> <span class="number">4</span> <span class="special">(</span> <span class="special">.</span> <span class="special">)</span> <span class="number">3</span>
</pre>
<p>
      The succeeding topics explain the VMD functionality for parsing a sequence
      for each individual VMD data type in that sequence.
    </p>
<h4>
<a name="variadic_macro_data.vmd_sequence.h3"></a>
      <span class="phrase"><a name="variadic_macro_data.vmd_sequence.sequence_types"></a></span><a class="link" href="vmd_sequence.html#variadic_macro_data.vmd_sequence.sequence_types">Sequence
      types</a>
    </h4>
<p>
      A VMD sequence can be seen as one of either three general types:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          An empty sequence
        </li>
<li class="listitem">
          A single element sequence
        </li>
<li class="listitem">
          A multi-element sequence
        </li>
</ol></div>
<p>
      An empty sequence is merely input that is empty, what VMD calls "emptiness".
      Use the previously explained BOOST_VMD_IS_EMPTY macro to test for an empty
      sequence.
    </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">AN_EMPTY_SEQUENCE</span>

<span class="identifier">BOOST_VMD_IS_EMPTY</span><span class="special">(</span><span class="identifier">AN_EMPTY_SEQUENCE</span><span class="special">)</span> <span class="identifier">will</span> <span class="keyword">return</span> <span class="number">1</span>
</pre>
<p>
      The type of an empty sequence is BOOST_VMD_TYPE_EMPTY.
    </p>
<p>
      A single element sequence is a single VMD data type. This is what we have been
      previously discussing as data which VMD can parse in this documentation with
      our identifying macros. You can use the BOOST_VMD_IS_UNARY macro to test for
      a single element sequence.
    </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">A_SINGLE_ELEMENT_SEQUENCE</span> <span class="special">(</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">)</span>

<span class="identifier">BOOST_VMD_IS_UNARY</span><span class="special">(</span><span class="identifier">A_SINGLE_ELEMENT_SEQUENCE</span><span class="special">)</span> <span class="identifier">will</span> <span class="keyword">return</span> <span class="number">1</span>
</pre>
<p>
      The type of a single element sequence is the type of the individual data type.
      In our example above the type of A_SINGLE_ELEMENT_SEQUENCE is BOOST_VMD_TYPE_TUPLE.
    </p>
<p>
      A multi-element sequence consists of more than one data type. This is the "new"
      type which VMD can parse. You can use the BOOST_VMD_IS_MULTI macro to test
      for a multi-element sequence.
    </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">A_MULTI_ELEMENT_SEQUENCE</span> <span class="special">(</span><span class="number">1</span><span class="special">,</span><span class="number">2</span><span class="special">)</span> <span class="special">(</span><span class="number">1</span><span class="special">)(</span><span class="number">2</span><span class="special">)</span> <span class="number">45</span>
</pre>
<p>
      The A_MULTI_ELEMENT_SEQUENCE consists of a tuple followed by a seq followed
      by a number.
    </p>
<pre class="programlisting"><span class="identifier">BOOST_VMD_IS_MULTI</span><span class="special">(</span><span class="identifier">A_MULTI_ELEMENT_SEQUENCE</span><span class="special">)</span> <span class="identifier">will</span> <span class="keyword">return</span> <span class="number">1</span>
</pre>
<p>
      The type of a multi-element sequence is always BOOST_VMD_TYPE_VSEQUENCE.
    </p>
<p>
      The type of a sequence can be obtained generically with the BOOST_VMD_GET_TYPE
      macro. We will be explaining this further in the documentation.
    </p>
<p>
      The size of any sequence can be accessed using the BOOST_VMD_SIZE macro. For
      an empty sequence the size is always 0. For a single element sequence the size
      is always 1. For a multi-element sequence the size is the number of individual
      top-level data types in the sequence.
    </p>
<pre class="programlisting"><span class="identifier">BOOST_VMD_SIZE</span><span class="special">(</span><span class="identifier">AN_EMPTY_SEQUENCE</span><span class="special">)</span> <span class="identifier">will</span> <span class="keyword">return</span> <span class="number">0</span>
<span class="identifier">BOOST_VMD_SIZE</span><span class="special">(</span><span class="identifier">A_SINGLE_ELEMENT_SEQUENCE</span><span class="special">)</span> <span class="identifier">will</span> <span class="keyword">return</span> <span class="number">1</span>
<span class="identifier">BOOST_VMD_SIZE</span><span class="special">(</span><span class="identifier">A_MULTI_ELEMENT_SEQUENCE</span><span class="special">)</span> <span class="identifier">will</span> <span class="keyword">return</span> <span class="number">3</span>
</pre>
<h4>
<a name="variadic_macro_data.vmd_sequence.h4"></a>
      <span class="phrase"><a name="variadic_macro_data.vmd_sequence.using_vmd_to_parse_sequence_inpu"></a></span><a class="link" href="vmd_sequence.html#variadic_macro_data.vmd_sequence.using_vmd_to_parse_sequence_inpu">Using
      VMD to parse sequence input</a>
    </h4>
<p>
      For a VMD sequence essentially two ways of parsing into individual data types
      are offered by the VMD library:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          The sequence can be converted to any of the Boost PP data types, or to
          variadic data, where each individual data type in the sequence becomes
          a separate element of the particular composite data type chosen. The conversion
          to a particular Boost PP data type or variadic data is slow, since it uses
          repetitive techniques to parse each element in the sequence, but afterwards
          accessing any individual element is as fast as accessing any element in
          the Boost PP data type or among variadic data.
        </li>
<li class="listitem">
          The sequence can be accessed directly through its individual elements.
          This is slower than accessing an element of a Boost PP data type or variadic
          data but offers conceptual access to the original sequence as a series
          of elements.
        </li>
</ol></div>
<p>
      These two techniques will be discussed in succeeding topics.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010-2015 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="vmd_generic.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="vmd_sequence_convert.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
